# 金山办公软件Android开发工程师笔试题（B卷）

## 一、问答题
### 1. ConcurrentHashMap 是怎么做并发控制的，相比 HashTable 有什么优势吗？

下面是对并发容器的简单介绍：

ConcurrentHashMap代替同步的Map（Collections.synchronized（new HashMap()）），众所周知，HashMap是根据散列值分段存储的，同步Map在同步的时候锁住了所有的段，而ConcurrentHashMap加锁的时候根据散列值锁住了散列值锁对应的那段，因此提高了并发性能。ConcurrentHashMap也增加了对常用复合操作的支持，比如"若没有则添加"：putIfAbsent()，替换：replace()。这2个操作都是原子操作。

CopyOnWriteArrayList和CopyOnWriteArraySet分别代替List和Set，主要是在遍历操作为主的情况下来代替同步的List和同步的Set，这也就是上面所述的思路：迭代过程要保证不出错，除了加锁，另外一种方法就是"克隆"容器对象。

ConcurrentLinkedQuerue是一个先进先出的队列。它是非阻塞队列。

ConcurrentSkipListMap可以在高效并发中替代SoredMap（例如用Collections.synchronzedMap包装的TreeMap）。

ConcurrentSkipListSet可以在高效并发中替代SoredSet（例如用Collections.synchronzedSet包装的TreeMap）。

### 2. 广播的两种注册方式有什么区别？

第一种是在配置文件里面进行静态注册，第二种是在代码中进行动态注册

两种注册类型的区别：

静态注册是当程序关闭后，如果有广播发过来，还能启动程序

动态注册的生命周期跟程序的生命周期是一样的，程序关闭后动态注册的广播是不能在接收到广播的

动态注册的优点：在Android的广播机制中，动态注册的优先级高于静态注册的优先级，因此在必要情况下，我们需要动态注册广播接收器。

静态注册的优点：动态注册广播接收器还有一个优点就是当用来注册广播的Activity关闭后，广播也就失效了，同时反映了静态注册广播的一个优势，就是无需担心广播接收器是否关闭，只要设备处于开启状态，广播接收器就能接收。

在AndroidManifest中进行注册后，不管改应用程序是否处于活动状态，都会进行监听，比如某个程序时监听 内存 的使用情况的，当在手机上安装好后，不管改应用程序是处于什么状态，都会执行改监听方法中的内容。

在代码中进行注册后，当应用程序关闭后，就不再进行监听。我们读知道，应用程序是否省电，决定了该应用程序的受欢迎程度，所以，对于那些没必要在程序关闭后仍然进行监听的Receiver，在代码中进行注册，无疑是一个明智的选择。

### 3. 安卓上，当系统资源不足时，会回收后台进程。请介绍一下Android的进程回收的策略（进程优先级）。如何应对系统回收时的数据保存与恢复。

前台进程
可见进程
服务进程
后台进程
空进程

### 4. 安卓上有哪些方式可以实现进程间通信？简述分别如何使用的。

bind机制（IPC->AIDL)

linux级共享内存

boradcast

Activity之间可以通过intent来传递数据

### 5. 以下代码的输出是什么？

	public class Main {
	
	    static class KOutput {
	        public KOutput(String msg) {
	            System.out.println(msg);
	        }
	    }
	
	    static class KDummy {
	        private KOutput m1;
	        private KOutput m2 = new KOutput("Hello");
	        private static final KOutput s3 = new KOutput("Java");
	
	        public KDummy() {
	            m1 = new KOutput("World");
	        }
	    }
	
	    public static void main(String[] args) {
	        KDummy kDummy = new KDummy();
	    }
	
	}

OUTPUT:

	Java
	Hello
	World


## 二、编程题

### 1. 现有一链表 G（A->B->C->D->E），需要你编写转换的代码，将链表 G 转换成 （A->B->C->D->E->D->C->B->A），链表节点的数据结构如下：

	public class Node{
		public Node next;
	}

### 2. 设有一正整数 A，将其划分成整形数组 B，B 的数组元素和等于 A，使得数组元素之间的乘积最大，即求 Z=a1\*a2\*...*am 最大（M>=1）。例如：A=1,B={1},Z=1；  A=2,B={2},Z=2； A=3,B={3},Z=3；A=4,B={4}或B={2,2},Z=4； A=5,B={2,3},Z=6；